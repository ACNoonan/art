import json

# --- Configuration ---
# Hardcode your input and output file paths here
INPUT_FILE_PATH = "/Users/adamnoonan/Documents/art/alejandro/twills-5-8-shafts/08sK advancing/08sK002.dtx"
OUTPUT_FILE_PATH = "/Users/adamnoonan/Documents/art/alejandro/twills-5-8-shafts/08sK advancing/08sK002-test.js"
# --------------------- 

def parse_dtx(dtx_content):
    """Parses the content of a DTX file into a structured dictionary."""
    data = {
        'info': {},
        'threading': [],
        'tieup': [],
        'treadling': []
    }
    current_section = None
    # Normalize section names to be consistent keys in our dictionary
    section_map = {
        'info': 'info',
        'threading': 'threading',
        'tieup': 'tieup',
        'treadling': 'treadling'
    }

    lines = dtx_content.split('\n')

    for line in lines:
        line = line.strip()
        if not line:
            continue

        if line.startswith('@@'):
            # When a section header is found, update the current context
            section_name = line.replace('@@', '').strip().lower()
            current_section = section_map.get(section_name)
            continue

        if current_section:
            if current_section == 'info' and line.startswith('%%'):
                # Parse key-value info pairs
                parts = line.replace('%%', '').strip().split()
                if len(parts) >= 2:
                    key = parts[0]
                    value = int(parts[1])
                    data['info'][key] = value
            elif current_section in ['threading', 'treadling']:
                # Parse space-separated numbers for threading and treadling
                numbers = [int(n) for n in line.split()]
                data[current_section].extend(numbers)
            elif current_section == 'tieup':
                # Parse binary strings for the tie-up matrix
                row = [int(char) for char in line]
                data['tieup'].append(row)

    return data

def generate_pattern(dtx_data):
    """Generates the 2D weave pattern based on parsed DTX data."""
    threading = dtx_data['threading']
    treadling = dtx_data['treadling']
    tieup = dtx_data['tieup']
    
    ends = dtx_data['info'].get('ends', len(threading))
    picks = dtx_data['info'].get('picks', len(treadling))

    if not all([threading, treadling, tieup]):
        raise ValueError("DTX data is incomplete. Threading, treadling, and tieup sections are required.")
        
    if len(threading) != ends:
         print(f"Warning: Threading length ({len(threading)}) does not match 'ends' in info section ({ends}).")
    if len(treadling) != picks:
         print(f"Warning: Treadling length ({len(treadling)}) does not match 'picks' in info section ({picks}).")

    # Initialize the pattern grid with 0s
    pattern = [[0 for _ in range(ends)] for _ in range(picks)]

    for row_idx in range(picks):
        # Determine which treadle is used for the current row (weft)
        treadle_num = treadling[row_idx]
        treadle_idx = treadle_num - 1 # Convert to 0-based index
        
        if not (0 <= treadle_idx < len(tieup)):
            print(f"Warning: Treadle number {treadle_num} at row {row_idx} is out of bounds for the tieup matrix. Skipping.")
            continue
            
        lifted_shafts = tieup[treadle_idx]

        for col_idx in range(ends):
            # Determine which shaft controls the current column (warp)
            shaft_num = threading[col_idx]
            shaft_idx = shaft_num - 1 # Convert to 0-based index

            if not (0 <= shaft_idx < len(lifted_shafts)):
                print(f"Warning: Shaft number {shaft_num} at column {col_idx} is out of bounds for the tieup matrix. Skipping.")
                continue

            # If the shaft is lifted (1), the warp thread is on top
            is_lifted = lifted_shafts[shaft_idx] == 1
            pattern[row_idx][col_idx] = 1 if is_lifted else 0
            
    return pattern

def generate_p5js_code(pattern, info, input_filename):
    """Generates a complete p5.js file as a string."""
    # Fallback to pattern dimensions if info section is missing
    tile_width = info.get('ends', len(pattern[0]) if pattern else 0)
    tile_height = info.get('picks', len(pattern) if pattern else 0)

    # Convert the Python list of lists to a JSON array string
    pattern_json = json.dumps(pattern, indent=2)

    p5_code = f"""
// This p5.js sketch was generated by a script from:
// {input_filename}

// The core weaving pattern data
const tilePattern = {pattern_json};

// Pattern dimensions
const tileWidth = {tile_width};
const tileHeight = {tile_height};

// Visual settings
const cellSize = 12;
const warpColor = '#222222'; // Color for warp threads (on top)
const weftColor = '#F0F0F0'; // Color for weft threads (on top)

function setup() {{
  createCanvas(tileWidth * cellSize, tileHeight * cellSize);
  noStroke();
  
  // The pattern is static, so we only need to draw it once.
  drawPattern();
  noLoop(); 
}}

function drawPattern() {{
  background(200);
  for (let y = 0; y < tileHeight; y++) {{
    for (let x = 0; x < tileWidth; x++) {{
      // tilePattern[y][x] === 1 means the warp thread is lifted
      if (tilePattern[y] && tilePattern[y][x] === 1) {{
        fill(warpColor);
      }} else {{
        fill(weftColor);
      }}
      rect(x * cellSize, y * cellSize, cellSize, cellSize);
    }}
  }}
}}
"""
    return p5_code

def main():
    """Main function to run the converter."""
    try:
        with open(INPUT_FILE_PATH, 'r', encoding='utf-8') as f:
            dtx_content = f.read()
    except FileNotFoundError:
        print(f"Error: Input file not found at '{INPUT_FILE_PATH}'")
        return
    except Exception as e:
        print(f"Error reading input file: {e}")
        return

    try:
        dtx_data = parse_dtx(dtx_content)
        pattern = generate_pattern(dtx_data)
        p5js_code = generate_p5js_code(pattern, dtx_data['info'], INPUT_FILE_PATH)

        with open(OUTPUT_FILE_PATH, 'w', encoding='utf-8') as f:
            f.write(p5js_code)
        
        print(f"Success! Converted '{INPUT_FILE_PATH}' to '{OUTPUT_FILE_PATH}'")

    except (ValueError, IndexError) as e:
        print(f"An error occurred during conversion: {e}")
        print("Please check that the input DTX file is valid and complete.")

if __name__ == '__main__':
    main() 